{
  "hash": "ee84c7d736114de605b28b2afee9bf0f",
  "result": {
    "markdown": "# Lab: Illusions\n\nIn the following labs we are going to look at visualisations. We will consider 3 'illusions' then misleading visualisations including bar plots, line plots and choropleths.\n\nFor this lab we will be using `Altair` - a plotting library which has more flexability than seaborn. It is a little more complex and examples can be found [here](https://altair-viz.github.io/gallery/). `Altair` is not installed by default in Anaconda, but it has been included in the virtual environment for this module. If you are using the course's virtual environment, this should be installed for you the first time you set up your environment for the module. Refer to @sec-setup for instructions on how to set up your environment.\n\n\n## Clustering illusion\n\nYou can find details of the clustering illusion [here](https://en.wikipedia.org/wiki/Clustering_illusion), [here](https://www.sciencedirect.com/science/article/abs/pii/004269899090160M), and [here](https://www.sciencedirect.com/science/article/pii/S0042698906000927).\n\nThe illusion suggests you should automatically try and see clusters in random data.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport seaborn as sns\nimport pandas as pd\nimport altair as alt\n\nn = 700\n\nd = {'x': np.random.uniform(0, 100, n), 'y': np.random.uniform(0, 100, n)}\ndf = pd.DataFrame(d)\n\nsns.relplot(data = df, x = 'x', y = 'y')\n```\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_6_1-illusions_files/figure-pdf/cell-2-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nThe syntax for building this type in Altair is pretty straight forward.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nalt.Chart(df).mark_circle(size=5).encode(\n    x='x',\n    y='y')\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nalt.Chart(...)\n```\n:::\n:::\n\n\nTo remove those pesky lines we need to specify we want an X and Y axis without grid lines.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nalt.Chart(df).mark_circle(size=5).encode(\n    alt.X('x', axis=alt.Axis(grid=False)),\n    alt.Y('y', axis=alt.Axis(grid=False)))\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nalt.Chart(...)\n```\n:::\n:::\n\n\nWe will do a lot of altering axis and colors in altair. We do this by specifying alt.axistype and then passing various options.\n\nDo you see any clustering the in the above plots? What about if we give names to the different columns?\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nalt.Chart(df).mark_circle(size=5).encode(\n    alt.X('x', axis=alt.Axis(grid=False, title='Height')),\n    alt.Y('y', axis=alt.Axis(grid=False, title='Weight')))\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\nalt.Chart(...)\n```\n:::\n:::\n\n\nAnother example of the clustering illusion is the idea of 'streaks'. That we see a pattern from a small sample and extrapolate out.\n\nWhat do you expect the next dice role to be?\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nn_rolls = 10\nd = {'round': np.linspace(1,n_rolls,n_rolls), 'roll': np.random.randint(1,6,n_rolls)}\ndf_dice = pd.DataFrame(d)\ndf_dice\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>round</th>\n      <th>roll</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1.0</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2.0</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>3.0</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>4.0</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>5.0</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>6.0</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>7.0</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>8.0</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>9.0</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>10.0</td>\n      <td>3</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nsns.scatterplot(data=df_dice, x='round', y='roll')\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n<Axes: xlabel='round', ylabel='roll'>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_6_1-illusions_files/figure-pdf/cell-7-output-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nalt.Chart(df_dice).mark_circle(size=20).encode(\n    alt.X('round', axis=alt.Axis(grid=False)),\n    alt.Y('roll', axis=alt.Axis(grid=False)))\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nalt.Chart(...)\n```\n:::\n:::\n\n\nEach number on the dice will occur the same number of times. Any patterns you see are due to extrapolating based on a small sample. We can check that though by rolling the 'dice' 1,000,000 times.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nn_rolls = 1000000\nd = {'round': np.linspace(1,n_rolls,n_rolls), 'roll': np.random.randint(1,6,n_rolls)}\ndf_dice_many = pd.DataFrame(d)\n\ndf_dice_many.groupby('roll').count()\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>round</th>\n    </tr>\n    <tr>\n      <th>roll</th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>1</th>\n      <td>199756</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>200436</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>199888</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>200560</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>199360</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Weber-Fechner Law\n\n\n\n> 'The Weber-Fechner Law is a famous finding of early psychophysics indicating that differences between stimuli are detected on a logarithmic scale. It takes more additional millimeters of radius to discern two larger circles than two smaller circles. This type of bias is probably one of the most researched biases in visualization research.' \n> \n> -- [@calero_valdez_studying_2018]\n\nLet us see if we can create a plot to demonstrate it.\n\nWe will load in the car crashes dataset from seaborn. Documentation of the data is [here](https://www.kaggle.com/fivethirtyeight/fivethirtyeight-bad-drivers-dataset).\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ndf_crashes = sns.load_dataset('car_crashes')\ndf_crashes.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>total</th>\n      <th>speeding</th>\n      <th>alcohol</th>\n      <th>not_distracted</th>\n      <th>no_previous</th>\n      <th>ins_premium</th>\n      <th>ins_losses</th>\n      <th>abbrev</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>18.8</td>\n      <td>7.332</td>\n      <td>5.640</td>\n      <td>18.048</td>\n      <td>15.040</td>\n      <td>784.55</td>\n      <td>145.08</td>\n      <td>AL</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>18.1</td>\n      <td>7.421</td>\n      <td>4.525</td>\n      <td>16.290</td>\n      <td>17.014</td>\n      <td>1053.48</td>\n      <td>133.93</td>\n      <td>AK</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>18.6</td>\n      <td>6.510</td>\n      <td>5.208</td>\n      <td>15.624</td>\n      <td>17.856</td>\n      <td>899.47</td>\n      <td>110.35</td>\n      <td>AZ</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>22.4</td>\n      <td>4.032</td>\n      <td>5.824</td>\n      <td>21.056</td>\n      <td>21.280</td>\n      <td>827.34</td>\n      <td>142.39</td>\n      <td>AR</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>12.0</td>\n      <td>4.200</td>\n      <td>3.360</td>\n      <td>10.920</td>\n      <td>10.680</td>\n      <td>878.41</td>\n      <td>165.63</td>\n      <td>CA</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nTo illustrate this 'illusion' we will plot the percentage of drivers speeding, percentage of alcohol impaired and set the size of the point equal to the percentage of drivers not previously involves in any accident. Each point is an american state.\n\nAre there any relationships or patterns in the data?\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nsns.scatterplot(data=df_crashes, x='speeding', y='alcohol', size='no_previous')\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n<Axes: xlabel='speeding', ylabel='alcohol'>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_6_1-illusions_files/figure-pdf/cell-11-output-2.pdf){fig-pos='H'}\n:::\n:::\n\n\nIs it easier to distinguish the different sizes in the below plot?\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nsns.scatterplot(data=df_crashes,\n                x='speeding',\n                y='alcohol',\n                size='no_previous',\n                sizes=(10,40))\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n<Axes: xlabel='speeding', ylabel='alcohol'>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_6_1-illusions_files/figure-pdf/cell-12-output-2.pdf){fig-pos='H'}\n:::\n:::\n\n\nHow about this one?\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nsns.scatterplot(data=df_crashes,\n                x='speeding',\n                y='alcohol',\n                size='no_previous',\n                sizes=(40,70))\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n<Axes: xlabel='speeding', ylabel='alcohol'>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_6_1-illusions_files/figure-pdf/cell-13-output-2.pdf){fig-pos='H'}\n:::\n:::\n\n\nThe values are the same. We have just changed the range of sizes.\n\nWe can do much the same in altair.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nalt.Chart(df_crashes).mark_circle().encode(\n    x='speeding',\n    y='alcohol',\n    size='no_previous'\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\nalt.Chart(...)\n```\n:::\n:::\n\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nalt.Chart(df_crashes).mark_circle().encode(\n    x='speeding',\n    y='alcohol',\n    size = alt.Size('no_previous', scale=alt.Scale(range=[10,40]))\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\nalt.Chart(...)\n```\n:::\n:::\n\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nalt.Chart(df_crashes).mark_circle().encode(\n    x='speeding',\n    y='alcohol',\n    size = alt.Size('no_previous', scale=alt.Scale(range=[40,70]))\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\nalt.Chart(...)\n```\n:::\n:::\n\n\nHave you come across any other illusions? If so, try and plot them out. I sometimes find it easier to understand these things through creating simple illustrations of my own.\n\n",
    "supporting": [
      "IM939_Lab_6_1-illusions_files/figure-pdf"
    ],
    "filters": []
  }
}