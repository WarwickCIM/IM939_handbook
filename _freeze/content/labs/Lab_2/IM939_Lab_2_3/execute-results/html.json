{
  "hash": "d9f884a1ad9e7a94e058a779125fbceb",
  "result": {
    "markdown": "# Lab: Missing data {#sec-pandas-transforming-data}\n\nOur data can contain missing values or benifit from transformations.\n\n## Missing values\n\nI have removed some of the ratings data in the office_ratings_missing.csv.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\ndf = pd.read_csv('data/raw/office_ratings_missing.csv', encoding = 'UTF-8')\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ndf.info()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 188 entries, 0 to 187\nData columns (total 6 columns):\n #   Column       Non-Null Count  Dtype  \n---  ------       --------------  -----  \n 0   season       188 non-null    int64  \n 1   episode      188 non-null    int64  \n 2   title        188 non-null    object \n 3   imdb_rating  170 non-null    float64\n 4   total_votes  168 non-null    float64\n 5   air_date     188 non-null    object \ndtypes: float64(2), int64(2), object(2)\nmemory usage: 8.9+ KB\n```\n:::\n:::\n\n\nWe are missing values in our imdb_rating and total votes columns.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndf.shape[0] - df.count()\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nseason          0\nepisode         0\ntitle           0\nimdb_rating    18\ntotal_votes    20\nair_date        0\ndtype: int64\n```\n:::\n:::\n\n\nWhat to do? A quick solution is to either 0 the values or give them a roughtly central value (the mean).\n\nTo do this we use the fillna method.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndf['imdb_rating_with_0'] = df['imdb_rating'].fillna(0)\n```\n:::\n\n\nTo fill with the mean.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndf['imdb_rating_with_mean'] = df['imdb_rating'].fillna(df['imdb_rating'].mean())\n```\n:::\n\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ndf.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>season</th>\n      <th>episode</th>\n      <th>title</th>\n      <th>imdb_rating</th>\n      <th>total_votes</th>\n      <th>air_date</th>\n      <th>imdb_rating_with_0</th>\n      <th>imdb_rating_with_mean</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>1</td>\n      <td>Pilot</td>\n      <td>7.6</td>\n      <td>NaN</td>\n      <td>24/03/2005</td>\n      <td>7.6</td>\n      <td>7.6</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>1</td>\n      <td>2</td>\n      <td>Diversity Day</td>\n      <td>8.3</td>\n      <td>3566.0</td>\n      <td>29/03/2005</td>\n      <td>8.3</td>\n      <td>8.3</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>1</td>\n      <td>3</td>\n      <td>Health Care</td>\n      <td>7.9</td>\n      <td>2983.0</td>\n      <td>05/04/2005</td>\n      <td>7.9</td>\n      <td>7.9</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>1</td>\n      <td>4</td>\n      <td>The Alliance</td>\n      <td>8.1</td>\n      <td>2886.0</td>\n      <td>12/04/2005</td>\n      <td>8.1</td>\n      <td>8.1</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>1</td>\n      <td>5</td>\n      <td>Basketball</td>\n      <td>8.4</td>\n      <td>3179.0</td>\n      <td>19/04/2005</td>\n      <td>8.4</td>\n      <td>8.4</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nWe can plot these to see what looks most reasonable (you can probably also make an educated guess here).\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndf['imdb_rating_with_mean'].plot()\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n<Axes: >\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_2_3_files/figure-html/cell-8-output-2.png){width=571 height=411}\n:::\n:::\n\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ndf['imdb_rating_with_0'].plot()\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n<Axes: >\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_2_3_files/figure-html/cell-9-output-2.png){width=566 height=411}\n:::\n:::\n\n\nGoing with the mean seems quite sensible in this case. Especially as the data is guassian so the mean is probably an accurate represenation of the central value.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nax = df['imdb_rating'].hist()\nax.axvline(df['imdb_rating'].mean(), color='k', linestyle='--')\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n<matplotlib.lines.Line2D at 0x146cd6250>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_2_3_files/figure-html/cell-10-output-2.png){width=566 height=411}\n:::\n:::\n\n\n## Transformations\n\nSome statistical models, such as standard linear regression, require the predicted variable to be gaussian distributed (a single central point and a roughly symmetrical decrease in frequency, see [this Wolfram alpha page](https://www.wolframalpha.com/input/?i=gaussian+0+1).\n\nThe distribution of votes is positively skewed (most values are low).\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ndf['total_votes'].hist()\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n<Axes: >\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_2_3_files/figure-html/cell-11-output-2.png){width=566 height=411}\n:::\n:::\n\n\nA log transformation can make this data closer to a guassian distributed data variable. For the log transformation we are going to use numpy (numerical python) which is a rather excellent library.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nimport numpy as np\n\ndf['total_votes_log'] = np.log2(df['total_votes'])\n```\n:::\n\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\ndf['total_votes_log'].hist()\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n<Axes: >\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_2_3_files/figure-html/cell-13-output-2.png){width=566 height=411}\n:::\n:::\n\n\nThat is less skewed, but not ideal. Perhaps a square root transformation instead?\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\ndf['total_votes_sqrt'] = np.sqrt(df['total_votes'])\ndf['total_votes_sqrt'].hist()\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n<Axes: >\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_2_3_files/figure-html/cell-14-output-2.png){width=566 height=411}\n:::\n:::\n\n\n...well, maybe a inverse/reciprocal transformation. It is possible we have hit the limit on what we can do.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\ndf['total_votes_recip'] = np.reciprocal(df['total_votes'])\ndf['total_votes_recip'].hist()\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n<Axes: >\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_2_3_files/figure-html/cell-15-output-2.png){width=566 height=411}\n:::\n:::\n\n\nAt this point, I think we should conceded that we can make the distribution less positively skewed. However, transformation are not magic and we cannot turn a heavily positively skewed distribution into a normally distributed one.\n\nOh well.\n\nWe can calculate z scores though so we can plot both total_votes and imdb_ratings on a single plot. Currently, the IMDB scores vary between 0 and 10 whereas the number of votes number in the thousands.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\ndf['total_votes_z'] = (df['total_votes'] - df['total_votes'].mean()) / df['total_votes'].std()\ndf['imdb_rating_z'] = (df['imdb_rating'] - df['imdb_rating'].mean()) / df['imdb_rating'].std()\n```\n:::\n\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\ndf['total_votes_z'].hist()\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n<Axes: >\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_2_3_files/figure-html/cell-17-output-2.png){width=566 height=411}\n:::\n:::\n\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\ndf['imdb_rating_z'].hist()\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n<Axes: >\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_2_3_files/figure-html/cell-18-output-2.png){width=566 height=411}\n:::\n:::\n\n\nNow we can compare the trends in score and number of votes on a single plot.\n\nWe are going to use a slightly different approach to creating the plots. Called to the plot() method from Pandas actually use a library called matplotlib. We are going to use the pyplot module of matplotlib directly.\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n```\n:::\n\n\nConvert the air date into a datetime object.\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\ndf['air_date'] =  pd.to_datetime(df['air_date'])\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/var/folders/7v/zl9mv52s3ls94kntlt_l9ryh0000gq/T/ipykernel_33624/2716201442.py:1: UserWarning: Parsing dates in %d/%m/%Y format when dayfirst=False (the default) was specified. Pass `dayfirst=True` or specify a format to silence this warning.\n  df['air_date'] =  pd.to_datetime(df['air_date'])\n```\n:::\n:::\n\n\nThen call the subplots function fom pyplot to create two plots. From this we take the two plot axis (ax1, ax2) and call the method scatter for each to plot imdb_rating_z and total_votes_z.\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nplt.style.use('ggplot')\n\nf, (ax1, ax2) = plt.subplots(1, 2, sharey=True)\nax1.scatter( df['air_date'], df['imdb_rating_z'], color = 'red')\nax1.set_title('IMDB rating')\nax2.scatter( df['air_date'], df['total_votes_z'], color = 'blue')\nax2.set_title('Total votes')\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\nText(0.5, 1.0, 'Total votes')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_2_3_files/figure-html/cell-21-output-2.png){width=569 height=434}\n:::\n:::\n\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nf\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n![](IM939_Lab_2_3_files/figure-html/cell-22-output-1.png){width=569 height=434}\n:::\n:::\n\n\nWe can do better than that.\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nplt.scatter(df['air_date'], df['imdb_rating_z'], color = 'red', alpha = 0.1)\nplt.scatter(df['air_date'], df['total_votes_z'], color = 'blue', alpha = 0.1)\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n<matplotlib.collections.PathCollection at 0x147ae0ad0>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_2_3_files/figure-html/cell-23-output-2.png){width=569 height=411}\n:::\n:::\n\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\n?plt.scatter\n```\n:::\n\n\nWe have done a lot so far. Exploring data in part 1, plotting data with the inbuilt Pandas methods in part 2 and dealing with both missing data and transfromations in part 3.\n\nIn part 4, we will look at creating your own functions, a plotting library called seaborn and introduce a larger dataset.\n\n",
    "supporting": [
      "IM939_Lab_2_3_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}